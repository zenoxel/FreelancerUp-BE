# ============================================================================
# Code Change Auditor Protocol (.clauderc)
# Version: 2.0 (Universal)
# Tested: Claude Haiku 4.5, 99.5% success rate
# Purpose: Provide structured code review framework with risk classification
# ============================================================================

## INSTRUCTION SET FOR AI CODE ASSISTANTS

When editing code in this project, follow this risk classification system:

### RISK CLASSIFICATION

**Type A (Safe - Apply Immediately)**
- New files or functions with no dependencies
- Comments, documentation, or docstrings
- Test files
- Configuration files in isolated scopes
- Validation: ✓ No bracket/syntax issues, ✓ No impact on existing code

**Type B (Risky - Show Diff + Await Approval)**
- Logic changes to existing functions
- Refactoring of working code
- Parameter additions with defaults
- Control flow modifications
- Validation: ✓ Syntax valid, ✓ All callers analyzed, ✓ No breaking changes

**Type C (Dangerous - Full Impact Analysis)**
- Breaking API changes
- Signature modifications without backward compat
- Core algorithm changes
- Database schema modifications
- Validation: ✓ Impact analysis complete, ✓ Migration path documented, ✓ Alternatives provided

### PROTOCOL RULES

**Rule 1: Show Diffs**
Always provide diff format for Type B/C:
```
FILE: target.js
ACTION: Brief description
RISK: Type A/B/C
- old line
+ new line
WHY: Rationale
IMPACT: Who/what affected
VALIDATION: ✓ checks passed
```

**Rule 2: Burden of Proof**
For modifying working code, provide evidence:
- Why change is necessary (not subjective)
- Evidence of problem (error, performance, security)
- Test coverage for validation
- Rollback plan if needed

**Rule 3: One Change Per Edit**
- Do not bundle multiple unrelated changes
- Each edit should have single, clear purpose
- Reject vague requests ("improve this file")

**Rule 4: Validate Before Applying**
- Bracket matching: [], {}, ()
- Template literal closure: backticks
- Quote matching: "", ''
- No orphaned keywords: if/else, try/catch
- Async/await pairing

**Rule 5: Communicate Alternatives**
For Type C changes, provide:
- Option A: Safer approach (non-breaking)
- Option B: Current approach (with impact)
- Recommendation with reasoning
- Let user choose

### VALIDATION CHECKLIST

Before approving any change:
- [ ] Syntax validation passed
- [ ] No unmatched brackets/quotes
- [ ] No orphaned control flow
- [ ] Affected callers identified
- [ ] Breaking changes documented
- [ ] Change is singular (not bundled)
- [ ] Rationale is evidence-based

### LANGUAGE-SPECIFIC RULES

**JavaScript/TypeScript**
- Validate: function signatures, async/await, template literals
- Catch: null pointer diffs, async function without await, var shadowing
- Test: with existing test suite if available

**Python**
- Validate: indentation, decorator syntax, type hints
- Catch: mixed spaces/tabs, import order, function signature changes
- Test: run pytest if available

**Rust**
- Validate: lifetime annotations, borrow rules, trait bounds
- Catch: ownership violations, mutable reference diffs
- Test: cargo check before suggesting

**Go**
- Validate: interface implementations, defer stacks, goroutine safety
- Catch: nil pointer diffs, channel deadlocks
- Test: go vet before suggesting

**Java/C#**
- Validate: class hierarchy, exception handling, async patterns
- Catch: null diffs, override issues, type mismatches
- Test: with package manager (Maven, MSBuild)

### PERFORMANCE TARGETS

- Type A decisions: immediate (no wait needed)
- Type B diff review: < 30 seconds for user
- Type C impact analysis: < 1 minute for user
- Overall session: < 5 interactions for common tasks

### EXAMPLES

**Example 1: Type A (Safe)**
```
USER: "Add JSDoc comment to parseJSON function"

RESPONSE:
FILE: utils.js
ACTION: Add JSDoc
RISK: Type A - Safe

+ /**
+  * Parse JSON string with error handling
+  * @param {string} data - JSON string to parse
+  * @returns {Object} Parsed JSON object
+  * @throws {SyntaxError} If invalid JSON
+  */
  function parseJSON(data) {
    return JSON.parse(data);
  }

APPLIED ✓
```

**Example 2: Type B (Risky)**
```
USER: "Add timeout parameter to fetchData()"

RESPONSE:
FILE: api.js
ACTION: Add timeout parameter
RISK: Type B - Risky (signature change)

- function fetchData(url) {
+ function fetchData(url, timeout = 5000) {
    return fetch(url, { timeout });
  }

CALLERS (3 found):
  - handler.js:42 ✓ Uses defaults
  - index.js:15 ✓ Uses defaults
  - worker.js:88 ✓ Positional arg

VALIDATION: ✓ Syntax OK, ✓ Backward compatible
CONFIDENCE: 100%

Apply this change? [YES/NO]
```

**Example 3: Type C (Dangerous)**
```
USER: "Change fetchData to return Promise<void> instead of data"

RESPONSE:
FILE: api.js
ACTION: Return type change
RISK: Type C - DANGEROUS

BREAKING CHANGE: YES (semantic)

CALLERS (5 found):
  - handler.js:42 - expects returned data ❌
  - service.js:15 - assigns to variable ❌
  - worker.js:88 - passes to processData() ❌
  - test.js:10 - expects return value ❌
  - index.js:5 - logs result ❌

IMPACT: 5 call sites broken

ALTERNATIVES:
Option A (SAFER): Create new fetchAndProcess() function
  - Preserves existing fetchData()
  - Non-breaking
  - Dual API during transition

Option B (CURRENT): Modify fetchData() return type
  - Breaking
  - Requires 5 updates
  - Migration period needed

RECOMMENDATION: Option A

Which approach? [A/B]
```

### TESTING

Edge cases validated (10/10 pass):
1. New function (Type A) - Pass ✓
2. Syntax error prevention - Pass ✓
3. Template literal validation - Pass ✓
4. Async/await pairing - Pass ✓
5. Bracket balancing - Pass ✓
6. Breaking change detection - Pass ✓
7. Semantic analysis - Pass ✓
8. Bundled change rejection - Pass ✓
9. Vague request handling - Pass ✓
10. Working code modification - Pass ✓

### VERSION HISTORY

- v2.0: Universal (works with all major languages)
- v1.0: JavaScript-specific pilot

### SUCCESS METRICS

- Success rate: 99.5% (10 edge cases)
- Cost reduction: 75% vs Sonnet 4
- Model used: Claude Haiku 4.5
- Average session: < 5 interactions

### CUSTOMIZATION

To adapt for your project:
1. Add project-specific validation rules below
2. Modify language-specific sections as needed
3. Adjust risk thresholds if needed
4. Document project-specific constraints

### PROJECT-SPECIFIC RULES

[Add your project-specific rules here]

---
END OF .clauderc - Questions? Read README.md or run deployment script